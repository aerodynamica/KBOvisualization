<!DOCTYPE html>
<meta charset="utf-8">
<title>Zoomable circle packing & wordcloud</title>
<link rel="stylesheet" type="text/css" href="css/bubble.css">
<link rel="stylesheet" type="text/css" href="css/general.css">
<link rel="stylesheet" type="text/css" href="css/bubbletip.css">
<link rel="stylesheet" type="text/css" href="css/sunbursttip.css">
<link rel="stylesheet" type="text/css" href="css/sequences.css">
<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous"/>
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Open+Sans:400,600">
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="libraries/d3.tip.js"></script>


<body>

    <div id="wordcloud">
        <script src="libraries/d3.layout.cloud.js"></script>
        <script>
var firstWord;            
            
        // Encapsulate the word cloud functionality
function wordCloud() {

    var fill = d3.scale.category20c();

    //Construct the word cloud's SVG element
    var svg = d3.select("#wordcloud").append("svg")
        .attr("width", 900)
        .attr("height", 900)
        .append("g")
        .attr("transform", "translate(450,450)");


    //Draw the word cloud
    function draw(words) {
        var cloud = svg.selectAll("g text")
                        .data(words, function(d) { return d.text; });
        
                
        //Entering words
        cloud.enter()
            .append("text")
            .style("font-family", "Impact")
            .style("fill", function(d, i) { return fill(i); })
            .attr("text-anchor", "middle")
            .attr('font-size', 1)
            .text(function(d) { return d.text; });

        //Entering and existing words
        cloud
            .transition()
                .duration(1000)
                //.style("font-size", function(d) { return d.size*scale; })
                .attr('font-size', function(d) { return d.size; })
                .attr("transform", function(d) {
                    return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
                })
                .style("fill-opacity", 1);

        //Exiting words
        cloud.exit()
            .transition()
                .duration(500)
                .style('fill-opacity', 1e-6)
                .attr('font-size', 1)
                .remove();
    }


    //Use the module pattern to encapsulate the visualisation code. We'll
    // expose only the parts that need to be public.
    return {

        //Recompute the word cloud for a new set of words. This method will
        // asycnhronously call draw when the layout has been computed.
        //The outside world will need to call this function, so make it part
        // of the wordCloud return value.
        update: function(words) {
            words = words.filter(isValidWord);
            
            firstWord = words[0].text;
            
            
            var scale = d3.scale.linear()
                    .domain(d3.extent(words,function(d) { return d.size; }))
                    .range([15,100]);
            
            
            d3.layout.cloud().size([900, 900])
                .words(words)
                .padding(5)
                .rotate(0) //function() { return ~~(Math.random() * 2) * 45; })
                .font("Impact")
                .fontSize(function(d) { return scale(d.size); })
                .on("end", draw)
                .start();
        }
    }

}    

var wordcloud = wordCloud();

updateCloud("root");


function updateCloud(activity){
    d3.json("wordclouds/"+activity+".json", function (error, names) {
                if (error)
                    throw error;
                
                wordcloud.update(names);
                
    });
}


function isValidWord(word){
    invalidwords = ["bvba","nv","sa","sprl","vzw","asbl"];
    if(invalidwords.indexOf(word.text) > -1){
        return false;
    }
    else{
        return true;
    }
}


       


        </script>



    </div>
    
    <div id="sunburst" class="navigation">
        <div id="sequence"></div>
        <div id="chart"></div>
    
        <script>
            // Dimensions of sunburst.
            var width = 800;
            var height = 800;
            var radius = (Math.min(width, height) / 2) - 10;

            // Breadcrumb dimensions: width, height, spacing, width of tip/tail.
            var b = {
                    w: 75, h: 30, s: 3, t: 10
            };

            var x = d3.scale.linear()
                    .range([0, 2 * Math.PI]);

            var y = d3.scale.sqrt()
                    .range([0, radius]);

            var color = d3.scale.category20();

            // Total size of all segments; we set this later, after loading the data.
            var totalSize = 0;

            var svg = d3.select("#chart").append("svg")
                    .attr("width", width)
                    .attr("height", height);

            var mainGroup = svg.append("g")
                    .attr("id", "container")
                    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");


            var partition = d3.layout.partition()
                    .value(function (d) {
                        return 1;
                    });

            var arc = d3.svg.arc()
                    .startAngle(function (d) {
                        return Math.max(0, Math.min(2 * Math.PI, x(d.x)));
                    })
                    .endAngle(function (d) {
                        return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));
                    })
                    .innerRadius(function (d) {
                        return Math.max(0, y(d.y));
                    })
                    .outerRadius(function (d) {
                        return Math.max(0, y(d.y + d.dy));
                    });

            // Basic setup of page elements.
            initializeBreadcrumbTrail();

            d3.select("#togglelegend").on("click", toggleLegend);

            var isChanging = false;

            // Keep track of the node that is currently being displayed as the root.
            var node;
            d3.json("activitiesAug.json", function (error, root) {
                if (error)
                    throw error;
                node = root;

                // Bounding circle underneath the sunburst, to make it easier to detect
                // when the mouse leaves the parent g.
                mainGroup.append("svg:circle")
                        .attr("r", radius)
                        .style("opacity", 0);
                
                //tooltip
                var tip = d3.tip()
                .attr('class', 'd3-tip');
        
                svg.call(tip);

                // For efficiency, filter nodes to keep only those large enough to see.
                var nodes = partition.nodes(root)
                        .filter(function (d) {
                            return (d.dx > 0.005); // 0.005 radians = 0.29 degrees
                        });

                var uniqueNames = (function (a) {
                    var output = [];
                    a.forEach(function (d) {
                        if (output.indexOf(d.Code) === -1) {
                            output.push(d.Code);
                        }
                    });
                    return output;
                })(nodes);

                // set domain of colors scale based on data
                color.domain(root.children.length);

                // make sure this is done after setting the domain
                drawLegend();

                var path = mainGroup.datum(root).selectAll("path")
                        .data(partition.nodes)
                        .enter().append("path")
                        .attr("d", arc)
                        .style("fill", function (d) {
                            var path = getAncestors(d);
                            if (path[0])
                                return color(path[0].Code);
                            else
                                return color((d.children ? d : d.parent).Code);
                        })
                        .on("mouseover",mouseover)
                        .on("mouseout", mouseout)
                        .on("mousemove", mousemove)
                        .on("click", click)
                        .each(stash);

                // Add the mouseleave handler to the bounding circle.
                d3.select("#container").on("mouseleave", mouseleave);

                // Get total size of the tree = value of root node from partition.
                totalSize = path.node().__data__.value;

                function click(d) {
                    updateCloud(d.Code);
                    node = d;
                    isChanging = true;
                    path.transition()
                            .duration(500)
                            .attrTween("d", arcTweenZoom(d))
                            .each("end", function () {
                                isChanging = false;
                            });
                }

                // Fade all but the current sequence, and show it in the breadcrumb trail.
                function mouseover(d) {
                    tip.html(d.Description);
                    tip.show();
                    
                    var percentage = (100 * d.value / totalSize).toPrecision(3);
                    var percentageString = percentage + "%";
                    if (percentage < 0.1) {
                        percentageString = "< 0.1%";
                    }

                    //d3.select("#percentage")
                    //	.text(percentageString);

                    //d3.select("#explanation")
                    //	.style("visibility", "");

                    var sequenceArray = getAncestors(d);
                    updateBreadcrumbs(sequenceArray, percentageString);

                    // Fade all the segments.
                    d3.selectAll("path")
                            .style("opacity", 0.3);

                    // Then highlight only those that are an ancestor of the current segment.
                    svg.selectAll("path")
                            .filter(function (node) {
                                return (sequenceArray.indexOf(node) >= 0);
                            })
                            .style("opacity", 1);
                }

                function mousemove(d) {
                    tip.show();
                }

                function mouseout(d) {
                    
                }

                // Restore everything to full opacity when moving off the visualization.
                function mouseleave(d) {
                    tip.hide();
                    if (!isChanging) {
                        var percentage = (100 * node.value / totalSize).toPrecision(3);
                        var percentageString = percentage + "%";
                        if (percentage < 0.1) {
                            percentageString = "< 0.1%";
                        }

                        var sequenceArray = getAncestors(node);
                        updateBreadcrumbs(sequenceArray, percentageString);

                        // Deactivate all segments during transition.
                        d3.selectAll("path").on("mouseover", null);

                        // Transition each segment to full opacity and then reactivate it.
                        d3.selectAll("path")
                                .transition()
                                .duration(500)
                                .style("opacity", 1)
                                .each("end", function () {
                                    d3.select(this).on("mouseover", mouseover);
                                });

                        d3.select("#explanation")
                                .transition()
                                .duration(500)
                                .style("visibility", "hidden");
                    }
                }
            });

            // Setup for switching data: stash the old values for transition.
            function stash(d) {
                d.x0 = d.x;
                d.dx0 = d.dx;
            }

            // When switching data: interpolate the arcs in data space.
            function arcTweenData(a, i) {
                var oi = d3.interpolate({x: a.x0, dx: a.dx0}, a);
                function tween(t) {
                    var b = oi(t);
                    a.x0 = b.x;
                    a.dx0 = b.dx;
                    return arc(b);
                }
                if (i == 0) {
                    // If we are on the first arc, adjust the x domain to match the root node
                    // at the current zoom level. (We only need to do this once.)
                    var xd = d3.interpolate(x.domain(), [node.x, node.x + node.dx]);
                    return function (t) {
                        x.domain(xd(t));
                        return tween(t);
                    };
                } else {
                    return tween;
                }
            }

            // When zooming: interpolate the scales.
            function arcTweenZoom(d) {
                var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]),
                        yd = d3.interpolate(y.domain(), [d.y, 1]),
                        yr = d3.interpolate(y.range(), [d.y ? 20 : 0, radius]);
                return function (d, i) {
                    return i ? function (t) {
                        return arc(d);
                    } : function (t) {
                        x.domain(xd(t));
                        y.domain(yd(t)).range(yr(t));
                        return arc(d);
                    };
                };
            }

            function initializeBreadcrumbTrail() {
                // Add the svg area.
                var trail = d3.select("#sequence").append("svg:svg")
                        .attr("width", width)
                        .attr("height", 50)
                        .attr("id", "trail");

                // Add the label at the end, for the percentage.
                trail.append("svg:text")
                        .attr("id", "endlabel")
                        .style("fill", "#000");
            }

            // Generate a string that describes the points of a breadcrumb polygon.
            function breadcrumbPoints(d, i) {
                var points = [];
                points.push("0,0");
                points.push(b.w + ",0");
                points.push(b.w + b.t + "," + (b.h / 2));
                points.push(b.w + "," + b.h);
                points.push("0," + b.h);
                if (i > 0) { // Leftmost breadcrumb; don't include 6th vertex.
                    points.push(b.t + "," + (b.h / 2));
                }
                return points.join(" ");
            }

            // Update the breadcrumb trail to show the current sequence and percentage.
            function updateBreadcrumbs(nodeArray, percentageString) {

                // Data join; key function combines name and depth (= position in sequence).
                var g = d3.select("#trail")
                        .selectAll("g")
                        .data(nodeArray, function (d) {
                            return d.Code + d.depth;
                        });

                // Add breadcrumb and label for entering nodes.
                var entering = g.enter().append("svg:g");

                entering.append("svg:polygon")
                        .attr("points", breadcrumbPoints)
                        .style("fill", function (d) {
                            return color(d.Code);
                        });

                entering.append("svg:text")
                        .attr("x", (b.w + b.t) / 2)
                        .attr("y", b.h / 2)
                        .attr("dy", "0.35em")
                        .attr("text-anchor", "middle")
                        .text(function (d) {
                            return d.Code;
                        });

                // Set position for entering and updating nodes.
                g.attr("transform", function (d, i) {
                    return "translate(" + i * (b.w + b.s) + ", 0)";
                });

                // Remove exiting nodes.
                g.exit().remove();

                // Now move and update the percentage at the end.
                d3.select("#trail").select("#endlabel")
                        .attr("x", (nodeArray.length + 0.5) * (b.w + b.s))
                        .attr("y", b.h / 2)
                        .attr("dy", "0.35em")
                        .attr("text-anchor", "middle")
                        .text(percentageString);

                // Make the breadcrumb trail visible, if it's hidden.
                d3.select("#trail")
                        .style("visibility", "");

            }

            // Given a node in a partition layout, return an array of all of its ancestor
            // nodes, highest first, but excluding the root.
            function getAncestors(node) {
                var path = [];
                var current = node;
                while (current.parent) {
                    path.unshift(current);
                    current = current.parent;
                }
                return path;
            }

            function drawLegend() {
                // Dimensions of legend item: width, height, spacing, radius of rounded rect.
                var li = {
                    w: 75, h: 30, s: 3, r: 3
                };

                var rootChildren = node.children;

                var legend = d3.select("#legend")
                        .append("svg:svg")
                        .attr("width", (li.w + li.s) * 2)
                        .attr("height", (li.h + li.s) * rootChildren.length);

                var g = legend.selectAll("g")
                        .data(rootChildren)
                        .enter()
                        .append("svg:g")
                        .attr("transform", function (d, i) {
                            return "translate(" + (i % 2) * (li.w + li.s) + "," + ((i / 2) | 0) * (li.h + li.s) + ")";
                        });

                g.append("svg:rect")
                        .attr("rx", li.r)
                        .attr("ry", li.r)
                        .attr("width", li.w)
                        .attr("height", li.h)
                        .style("fill", function (d) {
                            return color(d.Code);
                        });

                g.append("svg:text")
                        .attr("x", li.w / 2)
                        .attr("y", li.h / 2)
                        .attr("dy", "0.35em")
                        .attr("text-anchor", "middle")
                        .text(function (d) {
                            return d.Code;
                        });
            }

            function toggleLegend() {
                var legend = d3.select("#legend");
                if (legend.style("visibility") == "hidden") {
                    legend.style("visibility", "");
                } else {
                    legend.style("visibility", "hidden");
                }
            }

            function capitalizeFirstLetter(string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
            }
        </script>
    </div>


<!--    <div id="bubble" class="navigation">

        <script>

            var margin = 20,
                    diameter = 900;

            var color = d3.scale.linear()
                    .domain([-1, 5])
                    .range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
                    .interpolate(d3.interpolateHcl);

            var pack = d3.layout.pack()
                    .padding(2)
                    .size([diameter - margin, diameter - margin])
                    .sort(null)
                    .value(function (d) {
                        return d.nbEstablishments;
                    });

            var svg = d3.select("#bubble").append("svg")
                    .attr("width", diameter)
                    .attr("height", diameter)
                    .append("g")
                    .attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");

            d3.json("activitiesAug.json", function (error, root) {
                if (error)
                    throw error;
                
                
                var tip = d3.tip()
                .attr('class', 'd3-tip')
                .html(function(d) { return d.Description; });
        
                svg.call(tip);

                var focus = root,
                        nodes = pack.nodes(root),
                        view;

                var circle = svg.selectAll("circle")
                        .data(nodes)
                        .enter().append("circle")
                        .attr("class", function (d) {
                            return d.parent ? d.children ? "node" : "node node--leaf" : "node node--root";
                        })
                        .style("fill", function (d) {
                            return d.children ? color(d.depth) : null;
                        })
                        .on("click", function (d) {
                            if (focus !== d)
                                updateCloud(d.Code);
                                zoom(d), d3.event.stopPropagation();
                                
                        })
                        .on("mouseover", tip.show)
                         .on("mouseout", tip.hide);

                var text = svg.selectAll("text")
                        .data(nodes)
                        .enter().append("text")
                        .attr("class", "label")
                        .style("fill-opacity", function (d) {
                            return d.parent === root ? 1 : 0;
                        })
                        .style("display", function (d) {
                            return d.parent === root ? "inline" : "none";
                        })
                        .text(function (d) {
                            return d.Code;
                        });

                var node = svg.selectAll("circle,text");

               

                zoomTo([root.x, root.y, root.r * 2 + margin]);

                function zoom(d) {
                    var focus0 = focus;
                    focus = d;

                    var transition = d3.transition()
                            .duration(d3.event.altKey ? 7500 : 750)
                            .tween("zoom", function (d) {
                                var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2 + margin]);
                                return function (t) {
                                    zoomTo(i(t));
                                };
                            });

                    transition.selectAll("text")
                            .filter(function (d) {
                                return d.parent === focus || this.style.display === "inline";
                            })
                            .style("fill-opacity", function (d) {
                                return d.parent === focus ? 1 : 0;
                            })
                            .each("start", function (d) {
                                if (d.parent === focus)
                                    this.style.display = "inline";
                                
                            })
                            .each("end", function (d) {
                                if (d.parent !== focus)
                                    this.style.display = "none";
                            });
                }

                function zoomTo(v) {
                    var k = diameter / v[2];
                    view = v;
                    node.attr("transform", function (d) {
                        return "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")";
                    });
                    circle.attr("r", function (d) {
                        return d.r * k;
                    });
                }
                
                
                
                
                
            }
            );

            d3.select(self.frameElement).style("height", diameter + "px");
            
            
            
            

        </script>




    </div>-->




</body>
